#import "teaBASE.h"

@implementation teaBASE (SSH)

- (void)updateSSHStates {
    BOOL hasSSH = [self checkForSSH];
    BOOL hasSSHPassPhrase = hasSSH && [self checkForSSHPassPhrase]; // check both ∵ our pp-check is false-positive if no key file
    BOOL hasICloudIntegration = hasSSH && hasSSHPassPhrase && [self checkForSSHPassphraseICloudKeychainIntegration];
    
    [self.sshSwitch setState:hasSSH ? NSControlStateValueOn : NSControlStateValueOff];
    [self.sshPassPhraseSwitch setState:hasSSHPassPhrase ? NSControlStateValueOn : NSControlStateValueOff];
    [self.sshPassphraseICloudIntegrationSwitch setState:hasICloudIntegration ? NSControlStateValueOn : NSControlStateValueOff];
    
    self.sshPassPhraseSwitch.enabled = hasSSH;
    self.sshPassphraseICloudIntegrationSwitch.enabled = hasSSH;
}

- (NSString *)sshPrivateKeyFile {
    NSURL *home = [NSFileManager.defaultManager homeDirectoryForCurrentUser];
    
    //TODO filenames can be arbituary and configurable which makes life complex
    // eg. we could just try and figure out what is used for github, but that's not our *whole* story is it?
    
    //NOTE order is same as ssh sources read order
    for (NSString *file in @[@"id_rsa", @"id_dsa", @"id_ecdsa", @"id_ed25519"]) {
        NSString *path = [[home.path stringByAppendingPathComponent:@".ssh"] stringByAppendingPathComponent:file];
        if (![NSFileManager.defaultManager isReadableFileAtPath:path]) continue;
        if (![NSFileManager.defaultManager isReadableFileAtPath:[NSString stringWithFormat:@"%@.pub", path]]) continue;
        return path;
    }
    
    return nil;
}

- (BOOL)checkForSSH {
    return [self sshPrivateKeyFile] != nil;
}

- (BOOL)checkForSSHPassPhrase {
    id path = [self sshPrivateKeyFile];
    
    // attempts to decrypt the key, if there’s a passphrase this will fail
    return run(@"/usr/bin/ssh-keygen", @[@"-y", @"-f", path, @"-P", @""], nil) == NO;
}

- (BOOL)checkForSSHPassphraseICloudKeychainIntegration {
    NSURL *home = [NSFileManager.defaultManager homeDirectoryForCurrentUser];
    id path = [home.path stringByAppendingPathComponent:@".ssh/config"];
    return file_contains(path, @"UseKeychain yes");
}

- (IBAction)createSSHPrivateKey:(NSSwitch *)sender {
    id path = [self sshPrivateKeyFile] ?: [NSHomeDirectory() stringByAppendingPathComponent:@".ssh/id_ed25519"];
    
    if (sender.state == NSControlStateValueOn) {
        NSArray *arguments = @[@"-t", @"ed25519", @"-C", @"Generated by teaBASE", @"-f", path, @"-N", @""];
        
        if (run(@"/usr/bin/ssh-keygen", arguments, nil)) {
            [self calculateSecurityRating];
            [self updateSSHStates];
        } else {
            NSAlert *alert = [NSAlert new];
            alert.messageText = @"ssh-keygen failed";
            [alert runModal];
            [self.sshSwitch setState:NSControlStateValueOff];
        }
    } else {
        NSAlert *alert = [NSAlert new];
        alert.alertStyle = NSAlertStyleCritical;
        alert.messageText = @"Data Loss Warning";
        alert.informativeText = @"Deleting your SSH key pair cannot be undone by teaBASE.";
        
        NSButton *deleteButton = [alert addButtonWithTitle:@"Delete Keys"];
        deleteButton.hasDestructiveAction = YES;
        
        [alert addButtonWithTitle:@"Cancel"];
        
        [alert beginSheetModalForWindow:sender.window completionHandler:^(NSModalResponse returnCode) {
            if (returnCode == NSAlertFirstButtonReturn) {
                id err;
                if (![NSFileManager.defaultManager removeItemAtPath:path error:&err]) {
                    [[NSAlert alertWithError:err] runModal];
                    return;
                }
                id pubpath = [NSString stringWithFormat:@"%@.pub", path];
                if (![NSFileManager.defaultManager removeItemAtPath:pubpath error:&err]) {
                    [[NSAlert alertWithError:err] runModal];
                }
            }
            [self updateSSHStates];
        }];
    }
}

- (IBAction)createSSHPassPhrase:(NSSwitch *)sender {
    if (sender.state == NSControlStateValueOn) {
        [self.mainView.window beginSheet:self.sshPassphraseWindow completionHandler:^(NSModalResponse returnCode) {
            
            //TODO should not remove passphrase window until complete in case of failure
            
            if (returnCode == NSModalResponseCancel) {
                [self.sshPassPhraseSwitch setState:NSControlStateValueOff];
                return;
            }
            
            id path = [self sshPrivateKeyFile];
            
            id passphrase = self.sshPassphraseTextField.stringValue;
            
            NSPipe *pipe = [NSPipe pipe];
            
            if (!run(@"/usr/bin/ssh-keygen", @[@"-p", @"-N", passphrase, @"-f", path], pipe)) {
                id stderr = [NSString stringWithUTF8String:[pipe.fileHandleForReading readDataToEndOfFile].bytes];
                
                NSAlert *alert = [NSAlert new];
                alert.messageText = @"ssh-keygen failed";
                alert.informativeText = stderr;
                [alert runModal];
                return;
            }
            
            [self.sshPassphraseTextField setStringValue:@""]; // get it out of memory ASAP
            [self.sshPassPhraseSwitch setEnabled:NO];
            [self updateSSHStates];
            [self calculateSecurityRating];
        }];
    } else {
        [self.mainView.window beginSheet:self.sshRemovePassphraseWindow completionHandler:^(NSModalResponse returnCode) {
            if (returnCode == NSModalResponseCancel) {
                [sender setState:NSControlStateValueOn];
                return;
            }
            
            id path = [self sshPrivateKeyFile];
            id passphrase = self.sshRemovePassphraseTextField.stringValue;
            
            NSPipe *pipe = [NSPipe pipe];
            
            if (!run(@"/usr/bin/ssh-keygen", @[@"-p", @"-P", passphrase, @"-N", @"", @"-f", path], pipe)) {
                id stderr = [NSString stringWithUTF8String:[pipe.fileHandleForReading readDataToEndOfFile].bytes];
                
                NSAlert *alert = [NSAlert new];
                alert.messageText = @"Failed to remove passphrase. Incorrect passphrase?";
                alert.informativeText = stderr;
                [alert runModal];
                [sender setState:NSControlStateValueOn];
                [self.sshRemovePassphraseTextField setStringValue:@""]; // Clear passphrase from memory
                return;
            }
            
            [self.sshRemovePassphraseTextField setStringValue:@""]; // Clear passphrase from memory
            [self updateSSHStates];
            [self calculateSecurityRating];
        }];
    }
}

- (IBAction)createSSHPassPhraseStep2:(id)sender {
    NSAlert *alert = [NSAlert new];
    alert.messageText = @"Your passphrase won’t be stored";
    alert.informativeText = @"Please print the Emergency Kit and save it securely, or confirm you have another way to restore your credentials.\n\nDon’t worry—losing your SSH credentials is (usually—but tediously) recoverable.";
    [alert addButtonWithTitle:@"Print Kit"];
    [alert addButtonWithTitle:@"Proceed Without Kit"];
    [alert addButtonWithTitle:@"Cancel"];

    [alert beginSheetModalForWindow:self.sshPassphraseWindow completionHandler:^(NSModalResponse returnCode) {
        if (returnCode == NSAlertFirstButtonReturn) {
            [self printSSHEmergencyKit:self.sshPassphraseTextField.stringValue sender:sender];
        } else if (returnCode == NSAlertSecondButtonReturn) {
            [NSApp endSheet:self.sshPassphraseWindow returnCode:NSModalResponseOK];
        }
    }];
}

- (IBAction)removeSSHPassPhraseStep2:(id)sender {
    // We just need to go back to the main window's sheet
    [NSApp endSheet:self.sshRemovePassphraseWindow returnCode:NSModalResponseOK];
}

- (void)printSSHEmergencyKit:(NSString *)passphrase sender:(id)sender {
    NSString *privkey_path = [self sshPrivateKeyFile];
    NSString *pubkey_path = [NSString stringWithFormat:@"%@.pub", privkey_path];
    NSString *filename = [privkey_path lastPathComponent];
    NSError *error = nil;
    NSString *content = [NSString stringWithContentsOfFile:pubkey_path encoding:NSUTF8StringEncoding error:&error];
    
    if (error) {
        [[NSAlert alertWithError:error] runModal];
        return;
    }

    // Break the pubkic key content into 70-char lines (aligned with the private key visually) to make it fit the page
    NSMutableString *formattedContent = [NSMutableString string];
    NSUInteger lineLength = 70;
    NSUInteger currentIndex = 0;
    
    while (currentIndex < content.length) {
        NSUInteger remainingLength = content.length - currentIndex;
        NSUInteger substringLength = MIN(lineLength, remainingLength);
        NSRange range = NSMakeRange(currentIndex, substringLength);
        
        [formattedContent appendString:[content substringWithRange:range]];
        [formattedContent appendString:@"\n"];
        
        currentIndex += substringLength;
    }
    
    content = [NSString stringWithFormat:@"Recreate the following at: `~/.ssh/%@.pub`:\n\n%@", filename, formattedContent];
    
    NSString *privkey_content = [NSString stringWithContentsOfFile:privkey_path encoding:NSUTF8StringEncoding error:&error];
    
    if (error) {
        [[NSAlert alertWithError:error] runModal];
        return;
    }
    
    content = [content stringByAppendingString:@"\n\n"];
    content = [content stringByAppendingString:@"Recreate the following at: `~/.ssh/"];
    content = [content stringByAppendingString:filename];
    content = [content stringByAppendingString:@"\n\n"];
    content = [content stringByAppendingString:privkey_content];
    content = [content stringByAppendingString:@"\n\n"];
    
    content = [content stringByAppendingString:@"Passphrase:\n\n"];
    content = [content stringByAppendingString:passphrase];
        
    // Create an NSTextView and set the document content
    NSTextView *textView = [[NSTextView alloc] initWithFrame:NSMakeRect(0, 0, 612, 612)]; // Typical page size
    [textView setString:content];

    // Set font to Menlo (monospace) and make it smaller in order to fit the page
    NSFont *monoFont = [NSFont fontWithName:@"Menlo" size:10.4];
    [textView setFont:monoFont];
    [[textView textStorage] setFont:monoFont]; // Ensure the entire text storage uses the font
    
    // Configure the print operation for the text view
    NSPrintOperation *printOperation = [NSPrintOperation printOperationWithView:textView];
    [printOperation setShowsPrintPanel:YES];
    [printOperation setShowsProgressPanel:YES];
    [printOperation setJobTitle:@"SSH_Emergency_Kit.pdf"];

    // Run the print operation (this will display the print dialog)
    [printOperation runOperationModalForWindow:[sender window] delegate:self didRunSelector:@selector(sshPrintOperationDidRun:success:) contextInfo:nil];
}

- (void)sshPrintOperationDidRun:(NSPrintOperation *)op success:(BOOL)success {
    if (success) {
        [NSApp endSheet:self.sshPassphraseWindow returnCode:NSModalResponseOK];
    }
}

- (IBAction)configureSSHPassphraseICloudKeychainIntegration:(NSSwitch *)sender {
    NSURL *home = [NSFileManager.defaultManager homeDirectoryForCurrentUser];
    NSString *sshDir = [home.path stringByAppendingPathComponent:@".ssh"];
    NSString *ssh_config = [sshDir stringByAppendingPathComponent:@"config"];
    NSString *content = @"Host *\n  UseKeychain yes";

    // Create .ssh directory if it doesn't exist and set permissions
    if (![[NSFileManager defaultManager] fileExistsAtPath:sshDir]) {
        NSError *dirError = nil;
        [[NSFileManager defaultManager] createDirectoryAtPath:sshDir withIntermediateDirectories:YES attributes:@{NSFilePosixPermissions: @0700} error:&dirError];
        if (dirError) {
            [[NSAlert alertWithError:dirError] runModal];
            [sender setState:NSControlStateValueOff];
            return;
        }
    }

    if (sender.state == NSControlStateValueOn) {
        NSError *error = nil;
        NSString *existingContent = @"";
        BOOL exists = [[NSFileManager defaultManager] fileExistsAtPath:ssh_config];
        
        if (exists) {
            existingContent = [NSString stringWithContentsOfFile:ssh_config encoding:NSUTF8StringEncoding error:&error];
            if (error) {
                [[NSAlert alertWithError:error] runModal];
                [sender setState:NSControlStateValueOff];
                return;
            }
            existingContent = [existingContent stringByAppendingString:@"\n"];
        }
        
        NSString *newContent = [existingContent stringByAppendingString:[NSString stringWithFormat:@"%@\n", content]];
        NSError *writeError = nil;
        BOOL success = [newContent writeToFile:ssh_config atomically:YES encoding:NSUTF8StringEncoding error:&writeError];
        
        if (!success || writeError) {
            [[NSAlert alertWithError:writeError] runModal];
            [sender setState:NSControlStateValueOff];
            return;
        }

        // Check and set proper file permissions (600) if needed
        NSError *attributesError = nil;
        NSDictionary *currentAttributes = [[NSFileManager defaultManager] attributesOfItemAtPath:ssh_config error:&attributesError];
        if (attributesError) {
            [[NSAlert alertWithError:attributesError] runModal];
        } else {
            NSNumber *currentPermissions = [currentAttributes objectForKey:NSFilePosixPermissions];
            if (![currentPermissions isEqualToNumber:@0600]) {
                NSError *chmodError = nil;
                NSDictionary *attributes = @{NSFilePosixPermissions: @0600};
                [[NSFileManager defaultManager] setAttributes:attributes ofItemAtPath:ssh_config error:&chmodError];
                if (chmodError) {
                    [[NSAlert alertWithError:chmodError] runModal];
                    // Don't revert the switch state since the file was written successfully
                }
            }
        }
    } else {
        NSError *error = nil;
        NSString *fileContent = [NSString stringWithContentsOfFile:ssh_config encoding:NSUTF8StringEncoding error:&error];
        
        if (error) {
            [[NSAlert alertWithError:error] runModal];
            [sender setState:NSControlStateValueOn];
            return;
        }
        
        NSMutableArray *lines = [[fileContent componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]] mutableCopy];
        NSMutableArray *newLines = [NSMutableArray array];
        BOOL skipNextLine = NO;
        
        for (NSString *line in lines) {
            if (skipNextLine) {
                skipNextLine = NO;
                continue;
            }
            if ([line isEqualToString:@"Host *"]) {
                NSUInteger index = [lines indexOfObject:line];
                if (index + 1 < lines.count && [lines[index + 1] containsString:@"UseKeychain yes"]) {
                    skipNextLine = YES;
                    continue;
                }
            }
            [newLines addObject:line];
        }
        
        NSString *updatedContent = [[newLines componentsJoinedByString:@"\n"] stringByAppendingString:@"\n"];
        NSError *writeError = nil;
        BOOL success = [updatedContent writeToFile:ssh_config atomically:YES encoding:NSUTF8StringEncoding error:&writeError];
        
        if (!success || writeError) {
            [[NSAlert alertWithError:writeError] runModal];
            [sender setState:NSControlStateValueOn];
            return;
        }
    }
}

@end


@implementation teaBASE (NSTextFieldDelegate)

- (void)controlTextDidChange:(NSNotification *)obj {
    if ([obj.object isEqual:self.sshRemovePassphraseTextField]) {
        self.sshRemovePassphraseButton.enabled = self.sshRemovePassphraseTextField.stringValue.length > 0;
    } else {
        self.sshApplyPassphraseButton.enabled = self.sshPassphraseTextField.stringValue.length > 0;
    }
}

@end
